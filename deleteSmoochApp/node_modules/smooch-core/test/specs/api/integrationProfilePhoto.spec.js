import hat from 'hat';
import sinon from 'sinon';
import { Stream } from 'stream';
import { createReadStream } from 'streamifier';

import { testJwt } from '../../mocks/jwt';
import * as httpMock from '../../mocks/http';
import packageInfo from '../../../package.json';
import { buildTestHeaders } from '../testHeadersBuilder';
import { getAuthenticationHeaders } from '../../../src/utils/auth';
import { IntegrationProfilePhotoApi } from '../../../src/api/integrationProfilePhoto';

describe('Integration Profile Photo API', function() {
    const serviceUrl = 'http://some-url.com';
    const authHeaders = getAuthenticationHeaders({
        jwt: testJwt(),
    });
    const scope = 'account';
    const appId = hat();
    const integrationId = hat();
    let httpSpy;
    let api;

    beforeEach(function() {
        httpSpy = httpMock.mock();
        api = new IntegrationProfilePhotoApi({
            serviceUrl,
            authHeaders,
            scope,
            VERSION: packageInfo.version,
        });
    });

    afterEach(function() {
        httpMock.restore();
    });

    describe('#upload', function() {
        let source;
        const fullUrl = `${serviceUrl}/v1.1/apps/${appId}/integrations/${integrationId}/profile/photo`;

        beforeEach(() => {
            source = createReadStream('some source object');
        });

        describe('object syntax', function() {
            it('should call http', function() {
                return api
                    .upload({
                        appId,
                        integrationId,
                        source,
                    })
                    .then(() => {
                        httpSpy.args[0][0].should.eq('PUT');
                        httpSpy.args[0][1].should.eq(fullUrl);
                        httpSpy.args[0][2].should.be.instanceof(Stream);
                        httpSpy.args[0][2].should.be.instanceof(FormData);
                        httpSpy.args[0][3].should.eql(buildTestHeaders(authHeaders));
                    });
            });

            it('should also accept FormData', function() {
                const formData = new FormData();
                formData.append('source', source);

                return api
                    .upload({
                        appId,
                        integrationId,
                        source: formData,
                    })
                    .then(() => {
                        httpSpy.args[0][0].should.eq('PUT');
                        httpSpy.args[0][1].should.eq(fullUrl);
                        httpSpy.args[0][2].should.be.instanceof(Stream);
                        httpSpy.args[0][2].should.be.instanceof(FormData);
                        httpSpy.args[0][3].should.eql(buildTestHeaders(authHeaders));
                    });
            });

            it('should return an error if no source', function() {
                let error;

                try {
                    api.upload({
                        appId,
                        integrationId,
                        source: undefined,
                    });
                } catch (e) {
                    error = e;
                }

                expect(error).to.exist;
                error.message.should.equal('upload: missing required argument: source');
            });
        });

        describe('non-object syntax', function() {
            it('should call http with non-object syntax', function() {
                return api.upload(appId, integrationId, source).then(() => {
                    httpSpy.should.have.been.calledWith(
                        'PUT',
                        fullUrl,
                        sinon.match.instanceOf(FormData),
                        buildTestHeaders(authHeaders),
                    );
                });
            });

            it('should return an error if no source', function() {
                let error;

                try {
                    api.upload(appId, integrationId, undefined);
                } catch (e) {
                    error = e;
                }

                expect(error).to.exist;
                error.message.should.equal('Must provide source.');
            });
        });
    });
});
