import hat from 'hat';
import * as httpMock from '../../mocks/http';
import { getAuthenticationHeaders } from '../../../src/utils/auth';
import { AppUsersApi } from '../../../src/api/appUsers';
import { createReadStream } from 'streamifier';
import { testJwt } from '../../mocks/jwt';
import { buildTestHeaders } from '../testHeadersBuilder';
import packageInfo from '../../../package.json';

describe('AppUsers API', () => {
    const appId = 'app-id';
    const serviceUrl = 'http://some-url.com';
    const userId = 'user-id';
    const messageId = 'message-id';
    let authHeaders = getAuthenticationHeaders({
        jwt: testJwt(),
    });

    let httpSpy;
    let api;

    beforeEach(() => {
        httpSpy = httpMock.mock();
        api = new AppUsersApi({
            serviceUrl,
            authHeaders,
            VERSION: packageInfo.version,
        });
    });

    afterEach(() => {
        httpMock.restore();
    });

    it('should have the Stripe API', () => {
        api.stripe.should.exist;
    });

    it('should have the WeChat API', () => {
        api.wechat.should.exist;
    });

    describe('#get', () => {
        it('should call http', () => {
            return api.get(userId).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}`;

                httpSpy.should.have.been.calledWith('GET', fullUrl, undefined, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#update', () => {
        it('should call http', () => {
            const appUser = {
                email: 'new-email',
            };

            return api
                .update({
                    userId,
                    appUser,
                })
                .then(() => {
                    const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}`;
                    httpSpy.should.have.been.calledWith('PUT', fullUrl, appUser, buildTestHeaders(authHeaders));
                });
        });
    });

    describe('#create', () => {
        authHeaders = getAuthenticationHeaders({
            jwt: testJwt(),
        });

        let appUser;
        let jwtApi;

        beforeEach(() => {
            appUser = {
                email: hat(),
                userId: hat(),
            };

            jwtApi = new AppUsersApi({
                serviceUrl,
                authHeaders,
                VERSION: packageInfo.version,
            });
        });

        it('should call http', () => {
            return jwtApi
                .create({
                    appUser,
                })
                .then(() => {
                    const fullUrl = `${serviceUrl}/v1.1/appusers`;
                    httpSpy.should.have.been.calledWith(
                        'POST',
                        fullUrl,
                        {
                            userId: appUser.userId,
                            email: appUser.email,
                        },
                        buildTestHeaders(authHeaders),
                    );
                });
        });

        it('should throw if userId is missing', () => {
            delete appUser.userId;

            return jwtApi
                .create({
                    appUser,
                })
                .should.eventually.be.rejectedWith('Missing required argument: appUser.userId');
        });

        it('should throw if signedUpAt is not a date object', () => {
            return jwtApi
                .create({
                    appUser: {
                        ...appUser,
                        signedUpAt: 'not a date',
                    },
                })
                .should.eventually.be.rejectedWith('signedUpAt must be a date');
        });
    });

    describe('#getChannels', () => {
        it('should call http', () => {
            return api.getChannels(userId).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/channels`;

                httpSpy.should.have.been.calledWith('GET', fullUrl, undefined, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#getBusinessSystems', () => {
        it('should call http', () => {
            return api.getBusinessSystems(userId).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/businesssystems`;

                httpSpy.should.have.been.calledWith('GET', fullUrl, undefined, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#linkChannel', () => {
        it('should call http', () => {
            const data = {
                type: 'twilio',
                phoneNumber: '15145555555',
            };
            return api.linkChannel(userId, data).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/channels`;
                httpSpy.should.have.been.calledWith(
                    'POST',
                    fullUrl,
                    {
                        ...data,
                    },
                    buildTestHeaders(authHeaders),
                );
            });
        });

        it('should throw if no channelType provided', () => {
            return api.linkChannel(userId, {}).catch(() => {
                httpSpy.should.not.have.been.called;
            });
        });
    });

    describe('#unlinkChannel', () => {
        it('should call http', () => {
            return api.unlinkChannel(userId, 'twilio').then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/channels/twilio`;
                httpSpy.should.have.been.calledWith('DELETE', fullUrl, undefined, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#pingChannel', () => {
        it('should call http', () => {
            return api.pingChannel(userId, 'twilio').then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/integrations/twilio/ping`;
                httpSpy.should.have.been.calledWith('POST', fullUrl, undefined, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#getMessages', () => {
        it('should call http', () => {
            return api.getMessages(userId).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/messages`;
                httpSpy.should.have.been.calledWith('GET', fullUrl, undefined, buildTestHeaders(authHeaders));
            });
        });

        it('should call http with before param', () => {
            return api
                .getMessages(userId, {
                    before: 'XYZ',
                })
                .then(() => {
                    const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/messages`;
                    httpSpy.should.have.been.calledWith(
                        'GET',
                        fullUrl,
                        {
                            before: 'XYZ',
                        },
                        buildTestHeaders(authHeaders),
                    );
                });
        });

        it('should call http with after param', () => {
            return api
                .getMessages(userId, {
                    after: 'XYZ',
                })
                .then(() => {
                    const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/messages`;
                    httpSpy.should.have.been.calledWith(
                        'GET',
                        fullUrl,
                        {
                            after: 'XYZ',
                        },
                        buildTestHeaders(authHeaders),
                    );
                });
        });

        it('should throw if before and after are specified', () => {
            return api
                .getMessages(userId, {
                    before: 'XYZ',
                    after: 'XYZ',
                })
                .catch(() => {
                    httpSpy.should.not.have.been.called;
                });
        });
    });

    describe('#sendMessage', () => {
        it('should call http', () => {
            const message = {
                text: 'this is a message',
            };

            return api.sendMessage(userId, message).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/messages`;
                httpSpy.should.have.been.calledWith('POST', fullUrl, message, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#deleteMessage', () => {
        authHeaders = getAuthenticationHeaders({
            jwt: testJwt(),
        });

        it('should call http', () => {
            const jwtApi = new AppUsersApi({
                scope: 'account',
                serviceUrl,
                authHeaders,
                VERSION: packageInfo.version,
            });
            return jwtApi
                .deleteMessage({
                    appId,
                    userId,
                    messageId,
                })
                .then(() => {
                    const fullUrl = `${serviceUrl}/v1.1/apps/${appId}/appusers/${userId}/messages/${messageId}`;
                    httpSpy.should.have.been.calledWith('DELETE', fullUrl, undefined, buildTestHeaders(authHeaders));
                });
        });
    });

    describe('#deleteMessages', () => {
        authHeaders = getAuthenticationHeaders({
            jwt: testJwt(),
        });

        it('should call http', () => {
            const jwtApi = new AppUsersApi({
                serviceUrl,
                authHeaders,
                VERSION: packageInfo.version,
            });
            return jwtApi.deleteMessages(userId).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/messages`;
                httpSpy.should.have.been.calledWith('DELETE', fullUrl, {}, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#conversationActivity', () => {
        it('should call http', () => {
            const activity = {
                role: 'appMaker',
                type: 'typing:start',
            };

            return api.conversationActivity(userId, activity).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/conversation/activity`;
                httpSpy.should.have.been.calledWith('POST', fullUrl, activity, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#uploadImage', () => {
        it('should call http', () => {
            const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/images`;
            const source = createReadStream('some source object');
            const message = {
                text: 'this is a message',
            };

            return api.uploadImage(userId, source, message).then(() => {
                httpSpy.args[0][0].should.eq('POST');
                httpSpy.args[0][1].should.eq(fullUrl);
                httpSpy.args[0][2].should.be.instanceof(FormData);
                httpSpy.args[0][3].should.eql(buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#delete', () => {
        authHeaders = getAuthenticationHeaders({
            jwt: testJwt(),
        });

        it('should call http', () => {
            const jwtApi = new AppUsersApi({
                serviceUrl,
                authHeaders,
                VERSION: packageInfo.version,
            });
            return jwtApi.delete(userId).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}`;
                httpSpy.should.have.been.calledWith('DELETE', fullUrl, {}, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#deleteProfile', () => {
        authHeaders = getAuthenticationHeaders({
            jwt: testJwt(),
        });

        it('should call http', () => {
            const jwtApi = new AppUsersApi({
                serviceUrl,
                authHeaders,
                VERSION: packageInfo.version,
            });
            return jwtApi.deleteProfile(userId).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/profile`;
                httpSpy.should.have.been.calledWith('DELETE', fullUrl, {}, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#getLinkRequests', () => {
        it('should call http', () => {
            const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/linkrequest`;

            const integrationIds = ['5a04b5df045fedda49fa89f1', '5a04b5e0045fedda49fa89f2'];
            return api.getLinkRequests(userId, integrationIds).then(() => {
                httpSpy.should.have.been.calledWith(
                    'GET',
                    fullUrl,
                    {
                        integrationIds: integrationIds.join(','),
                    },
                    buildTestHeaders(authHeaders),
                );
            });
        });

        it('should throw if no type provided', () => {
            expect(() => api.getLinkRequests(userId)).to.throw(Error);
        });
    });

    describe('#getAuthCode', () => {
        it('should call http', () => {
            return api.getAuthCode(userId).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/${userId}/authcode`;
                httpSpy.should.have.been.calledWith('GET', fullUrl, undefined, buildTestHeaders(authHeaders));
            });
        });
    });

    describe('#mergeUsers', () => {
        it('should call http', () => {
            const properties = {
                surviving: {
                    _id: 'some-id',
                },
                discarded: {
                    _id: 'some-other-id',
                },
            };

            return api.mergeUsers(properties).then(() => {
                const fullUrl = `${serviceUrl}/v1.1/appusers/merge`;
                httpSpy.should.have.been.calledWith('POST', fullUrl, properties, buildTestHeaders(authHeaders));
            });
        });

        it('should call http with object style', () => {
            const properties = {
                surviving: {
                    _id: 'some-id',
                },
                discarded: {
                    _id: 'some-other-id',
                },
            };

            return api
                .mergeUsers({
                    appId,
                    props: properties,
                })
                .then(() => {
                    const fullUrl = `${serviceUrl}/v1.1/appusers/merge`;
                    httpSpy.should.have.been.calledWith('POST', fullUrl, properties, buildTestHeaders(authHeaders));
                });
        });
    });
});
