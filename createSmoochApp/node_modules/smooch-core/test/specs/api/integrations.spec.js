import hat from 'hat';

import * as httpMock from '../../mocks/http';
import { getAuthenticationHeaders } from '../../../src/utils/auth';
import { IntegrationsApi } from '../../../src/api/integrations';
import { testJwt } from '../../mocks/jwt';
import { buildTestHeaders } from '../testHeadersBuilder';
import packageInfo from '../../../package.json';

describe('Integrations API', () => {
    const serviceUrl = 'http://some-url.com';
    const missingParams = 'incorrect number of parameters';
    const authHeaders = getAuthenticationHeaders({
        jwt: testJwt(),
    });
    const scope = 'account';
    const appId = 'appid_12345';
    let httpSpy;
    let api;

    beforeEach(() => {
        httpSpy = httpMock.mock();
        api = new IntegrationsApi({
            serviceUrl,
            authHeaders,
            scope,
            VERSION: packageInfo.version,
        });
    });

    afterEach(() => {
        httpMock.restore();
    });

    describe('#create', () => {
        it('should throw if props are not provided', () => {
            expect(() => api.create(appId)).to.throw(Error, missingParams);
        });

        it('should throw if props are empty', () => {
            expect(() => api.create(appId, {})).to.throw(Error, 'props missing required field type');
        });

        describe('web messenger', () => {
            it('should call http', () => {
                const props = {
                    type: 'web',
                    integrationOrder: ['59fc8466260f48003505228b', '59d79780481d34002b7d3617'],
                    businessName: 'foo',
                    brandColor: '00ff00',
                    conversationColor: 'dd00ee',
                    actionColor: 'eeff00',
                    displayStyle: 'button',
                    businessIconUrl: 'https://pbs.twimg.com/media/CtooA-VWIAAViqN.jpg',
                    buttonIconUrl: 'https://pbs.twimg.com/media/CtooA-VWIAAViqN.jpg',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });
        });

        describe('messenger', () => {
            it('should throw if missing required params', () => {
                const invalid = {
                    type: 'messenger',
                };
                expect(() => api.create(appId, invalid)).to.throw(
                    Error,
                    'integration has missing required keys: pageAccessToken, appId, appSecret',
                );
            });

            it('should call http', () => {
                const props = {
                    type: 'messenger',
                    pageAccessToken: 'foo',
                    appId: 'bar',
                    appSecret: 'baz',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });
        });

        describe('twitter', () => {
            it('should throw if missing required params', () => {
                const invalid = {
                    type: 'twitter',
                };
                expect(() => api.create(appId, invalid)).to.throw(
                    Error,
                    'integration has missing required keys: consumerKey, consumerSecret, accessTokenKey, accessTokenSecret',
                );
            });

            it('should call http', () => {
                const props = {
                    tier: 'premium',
                    envName: 'env-beta',
                    type: 'twitter',
                    consumerKey: 'foo',
                    consumerSecret: 'bar',
                    accessTokenKey: 'baz',
                    accessTokenSecret: 'schwifty',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });
        });

        describe('mailgun', () => {
            it('should throw if missing required params', () => {
                const invalid = {
                    type: 'mailgun',
                };
                expect(() => api.create(appId, invalid)).to.throw(
                    Error,
                    'integration has missing required keys: apiKey, domain, incomingAddress',
                );
            });

            it('should call http', () => {
                const props = {
                    type: 'mailgun',
                    apiKey: 'foo',
                    domain: 'bar',
                    incomingAddress: 'baz',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });
        });

        describe('twilio', () => {
            it('should throw if missing required params', () => {
                const invalid = {
                    type: 'twilio',
                };
                expect(() => api.create(appId, invalid)).to.throw(
                    Error,
                    'integration has missing required keys: accountSid, authToken, phoneNumberSid',
                );
            });

            it('should call http', () => {
                const props = {
                    type: 'twilio',
                    accountSid: 'foo',
                    authToken: 'bar',
                    phoneNumberSid: 'baz',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });
        });

        describe('telegram', () => {
            it('should throw if missing required params', () => {
                const invalid = {
                    type: 'telegram',
                };
                expect(() => api.create(appId, invalid)).to.throw(
                    Error,
                    'integration has missing required keys: token',
                );
            });

            it('should call http', () => {
                const props = {
                    type: 'telegram',
                    token: 'foo',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });
        });

        describe('line', () => {
            it('should throw if missing required params', () => {
                const invalid = {
                    type: 'line',
                };
                expect(() => api.create(appId, invalid)).to.throw(
                    Error,
                    'integration has missing required keys: (channelId or channelAccessToken), channelSecret',
                );
            });

            it('should call http', () => {
                const props = {
                    type: 'line',
                    channelAccessToken: 'foo',
                    channelSecret: 'bar',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });
        });

        describe('viber', () => {
            it('should throw if missing required params', () => {
                const invalid = {
                    type: 'viber',
                };
                expect(() => api.create(appId, invalid)).to.throw(
                    Error,
                    'integration has missing required keys: token',
                );
            });

            it('should call http', () => {
                const props = {
                    type: 'viber',
                    token: 'foo',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });
        });

        describe('wechat', () => {
            it('should throw if missing required params', () => {
                const invalid = {
                    type: 'wechat',
                };
                expect(() => api.create(appId, invalid)).to.throw(
                    Error,
                    'integration has missing required keys: appId, appSecret',
                );
            });

            it('should call http', () => {
                const props = {
                    type: 'wechat',
                    appId: 'foo',
                    appSecret: 'bar',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });

            it('should call http with optional props', () => {
                const props = {
                    type: 'wechat',
                    appId: 'foo',
                    appSecret: 'bar',
                    encodingAesKey: 'baz',
                    accessTokenUrl: 'foo.bar',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });
        });

        describe('whatsapp', function() {
            it('should not throw if missing required params and call the server', function() {
                const invalid = {
                    type: 'whatsapp',
                };

                return api.create(appId, invalid).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, invalid, buildTestHeaders(authHeaders));
                });
            });

            describe('Using Smooch’s WhatsApp API Client hosting', function() {
                it('should call http', function() {
                    const props = {
                        type: 'whatsapp',
                        deploymentId: hat(),
                    };

                    return api.create(appId, props).then(() => {
                        const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                        httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                    });
                });

                it('should accept the optional parameter', function() {
                    const props = {
                        type: 'whatsapp',
                        deploymentId: hat(),
                        hsmFallbackLanguage: 'fr_CA',
                    };

                    return api.create(appId, props).then(() => {
                        const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                        httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                    });
                });
            });

            describe('Using plain credentials (deprecated)', function() {
                it('should call http', function() {
                    const props = {
                        type: 'whatsapp',
                        baseUrl: hat(),
                        username: hat(),
                        password: hat(),
                    };

                    return api.create(appId, props).then(() => {
                        const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                        httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                    });
                });

                it('should accept the optional parameter', function() {
                    const props = {
                        type: 'whatsapp',
                        baseUrl: hat(),
                        username: hat(),
                        password: hat(),
                        hsmFallbackLanguage: 'fr_CA',
                    };

                    return api.create(appId, props).then(() => {
                        const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                        httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                    });
                });
            });
        });

        describe('fcm', () => {
            it('should throw if missing required params', () => {
                const invalid = {
                    type: 'fcm',
                };

                expect(() => api.create(appId, invalid)).to.throw(
                    Error,
                    'integration has missing required keys: serverKey, senderId',
                );
            });

            it('should call http', () => {
                const props = {
                    type: 'fcm',
                    serverKey: 'yay',
                    senderId: 'woo',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });
        });

        describe('apn', () => {
            it('should throw if missing required params', () => {
                const invalid = {
                    type: 'apn',
                };

                expect(() => api.create(appId, invalid)).to.throw(
                    Error,
                    'integration has missing required keys: certificate',
                );
            });

            it('should call http', () => {
                const props = {
                    type: 'apn',
                    certificate: 'yay',
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });

            it('should call http with optional props', () => {
                const props = {
                    type: 'apn',
                    certificate: 'yay',
                    password: 'oooooh',
                    autoUpdateBadge: true,
                };
                return api.create(appId, props).then(() => {
                    const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                    httpSpy.should.have.been.calledWith('POST', url, props, buildTestHeaders(authHeaders));
                });
            });

            it('should throw an error if the property types are wrong', () => {
                const props = {
                    type: 'apn',
                    certificate: {},
                    autoUpdateBadge: 12345,
                    password: false,
                };

                const expectedTypes = [
                    {
                        name: 'certificate',
                        type: 'string',
                    },
                    {
                        name: 'autoUpdateBadge',
                        type: 'boolean',
                    },
                    {
                        name: 'password',
                        type: 'string',
                    },
                ];

                expect(() => api.create(appId, props)).to.throw(
                    Error,
                    `integration has invalid types: ${JSON.stringify(expectedTypes)}`,
                );
            });
        });
    });

    describe('#list', () => {
        const limit = 42;
        const offset = 99;

        it('should call http', () => {
            return api.list(appId).then(() => {
                const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                httpSpy.should.have.been.calledWith('GET', url, {}, buildTestHeaders(authHeaders));
            });
        });

        it('should use limit cc', () => {
            return api.list(appId, null, limit).then(() => {
                const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                httpSpy.should.have.been.calledWith(
                    'GET',
                    url,
                    {
                        limit,
                    },
                    buildTestHeaders(authHeaders),
                );
            });
        });

        it('should use offset', () => {
            return api.list(appId, null, null, offset).then(() => {
                const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                httpSpy.should.have.been.calledWith(
                    'GET',
                    url,
                    {
                        offset,
                    },
                    buildTestHeaders(authHeaders),
                );
            });
        });

        it('should use limit and offset', () => {
            return api.list(appId, null, limit, offset).then(() => {
                const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                httpSpy.should.have.been.calledWith(
                    'GET',
                    url,
                    {
                        limit,
                        offset,
                    },
                    buildTestHeaders(authHeaders),
                );
            });
        });

        it('should accept types string', () => {
            const types = 'type1,type2';
            return api.list(appId, types).then(() => {
                const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                httpSpy.should.have.been.calledWith(
                    'GET',
                    url,
                    {
                        types,
                    },
                    buildTestHeaders(authHeaders),
                );
            });
        });

        it('should accept types array', () => {
            const types = ['type1', 'type2'];
            return api.list(appId, types).then(() => {
                const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                httpSpy.should.have.been.calledWith(
                    'GET',
                    url,
                    {
                        types: 'type1,type2',
                    },
                    buildTestHeaders(authHeaders),
                );
            });
        });

        it('should use all parameters', () => {
            const types = ['type1', 'type2'];
            return api.list(appId, types, limit, offset).then(() => {
                const url = `${serviceUrl}/v1.1/apps/${appId}/integrations`;
                httpSpy.should.have.been.calledWith(
                    'GET',
                    url,
                    {
                        types: 'type1,type2',
                        limit,
                        offset,
                    },
                    buildTestHeaders(authHeaders),
                );
            });
        });

        it('should reject non-number limit and offset', () => {
            [['banana'], ['apple', true], [undefined, {}]].forEach((invalid) => {
                expect(() => api.list(appId, null, ...invalid)).to.throw(Error, 'must be a number');
            });
        });
    });

    describe('#get', () => {
        it('should call http', () => {
            const integrationId = 'integration_123456';
            return api.get(appId, integrationId).then(() => {
                const url = `${serviceUrl}/v1.1/apps/${appId}/integrations/${integrationId}`;
                httpSpy.should.have.been.calledWith('GET', url, undefined, buildTestHeaders(authHeaders));
            });
        });

        it('should throw if missing integrationId', () => {
            expect(() => api.get(appId)).to.throw(Error, missingParams);
        });
    });

    describe('#update', () => {
        it('should call http', () => {
            const integrationId = 'integration_123456';
            return api.update(appId, integrationId, {}).then(() => {
                const url = `${serviceUrl}/v1.1/apps/${appId}/integrations/${integrationId}`;
                httpSpy.should.have.been.calledWith('PUT', url, {}, buildTestHeaders(authHeaders));
            });
        });

        it('should throw error if missing integrationId', () => {
            expect(() => api.update(appId)).to.throw(Error, missingParams);
        });
    });

    describe('#delete', () => {
        it('should call http', () => {
            const integrationId = 'integration_123456';
            return api.delete(appId, integrationId).then(() => {
                const url = `${serviceUrl}/v1.1/apps/${appId}/integrations/${integrationId}`;
                httpSpy.should.have.been.calledWith('DELETE', url, undefined, buildTestHeaders(authHeaders));
            });
        });

        it('should throw error if missing integrationId', () => {
            expect(() => api.delete(appId)).to.throw(Error, missingParams);
        });
    });
});
